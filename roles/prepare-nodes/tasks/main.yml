# Wait for any background apt/dpkg process to finish before we touch packages
- name: Wait for apt lock to be released
  shell: |
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || \
          fuser /var/lib/apt/lists/lock >/dev/null 2>&1; do
      echo "Waiting for apt lock..."; sleep 5;
    done
  changed_when: false

# Refresh package index so we get latest versions
- name: Update apt cache
  apt:
    update_cache: yes
    cache_valid_time: 3600

# Install tools required by Kubernetes, Kubespray, and general node operation
- name: Install required base packages
  apt:
    name:
      - curl
      - wget
      - git
      - vim
      - net-tools
      - python3-pip
      - python3-netaddr
      - python3-setuptools
      - apt-transport-https
      - ca-certificates
      - gnupg
      - lsb-release
      - socat
      - conntrack
      - ipset
      - ipvsadm
      - nfs-common
      - chrony
      - rsync
      - unzip
    state: present
    update_cache: yes

# Kubernetes requires swap off — kubelet won't start if swap is active
- name: Disable swap immediately
  command: swapoff -a
  when: ansible_swaptotal_mb > 0
  changed_when: true

# Prevent swap from re-enabling after reboot
- name: Remove swap from /etc/fstab permanently
  replace:
    path: /etc/fstab
    regexp: '^([^#].*?\sswap\s+\S+\s+.*)$'
    replace: '# \1'

# Load networking + IPVS modules needed by containerd and kube-proxy
- name: Load required kernel modules now
  modprobe:
    name: "{{ item }}"
    state: present
  loop: [br_netfilter, overlay, ip_vs, ip_vs_rr, ip_vs_wrr, ip_vs_sh, nf_conntrack]

# Ensure modules are still loaded after reboot
- name: Persist kernel modules across reboots
  copy:
    dest: /etc/modules-load.d/k8s.conf
    content: |
      br_netfilter
      overlay
      ip_vs
      ip_vs_rr
      ip_vs_wrr
      ip_vs_sh
      nf_conntrack

# Enable IP forwarding and bridge traffic visibility required for pod networking
- name: Apply sysctl settings for Kubernetes
  sysctl:
    name: "{{ item.key }}"
    value: "{{ item.value }}"
    sysctl_set: yes
    state: present
    reload: yes
  loop:
    - { key: 'net.bridge.bridge-nf-call-iptables',  value: '1' }
    - { key: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
    - { key: 'net.ipv4.ip_forward',                 value: '1' }
    - { key: 'net.ipv4.conf.all.rp_filter',         value: '1' }
    - { key: 'vm.max_map_count',                     value: '262144' }
    - { key: 'fs.inotify.max_user_watches',          value: '524288' }
    - { key: 'fs.inotify.max_user_instances',        value: '512' }
    - { key: 'kernel.pid_max',                       value: '4194304' }

# Set hostname so it matches the Ansible inventory name (needed for TLS certs)
- name: Set hostname to match inventory name
  hostname:
    name: "{{ inventory_hostname }}"

# Let every node resolve every other node by name via internal IP
- name: Add all cluster nodes to /etc/hosts (internal IPs)
  lineinfile:
    path: /etc/hosts
    regexp: "^.*{{ item }}$"
    line: "{{ hostvars[item]['ip'] }} {{ item }}"
    state: present
  loop: "{{ groups['all'] }}"

# Raise open file/process limits — default Linux values are too low for Kubernetes
- name: Set file descriptor limits
  pam_limits:
    domain: '*'
    limit_type: "{{ item.type }}"
    limit_item: "{{ item.item }}"
    value: "{{ item.value }}"
  loop:
    - { type: 'soft', item: 'nofile',   value: '1048576' }
    - { type: 'hard', item: 'nofile',   value: '1048576' }
    - { type: 'soft', item: 'nproc',    value: 'unlimited' }
    - { type: 'hard', item: 'nproc',    value: 'unlimited' }

# Sync clocks across all nodes — clock drift breaks etcd and TLS certificates
- name: Start and enable chrony (NTP)
  systemd:
    name: chrony
    state: started
    enabled: yes

# UFW would block Kubespray's iptables rules — disable it entirely
- name: Disable UFW
  systemd:
    name: ufw
    state: stopped
    enabled: no
  ignore_errors: yes  # UFW may not be installed, that's fine

- name: Node preparation complete
  debug:
    msg: "✅ Node {{ inventory_hostname }} prepared ({{ ansible_host }})"